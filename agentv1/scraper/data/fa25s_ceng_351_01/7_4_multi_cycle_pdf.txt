Chapter 7 :: Microarchitecture Click to edit Master title style Digital Design and Computer Architecture David Money Harris and Sarah L. Harris 7-<1>
 Chapter 7 :: Topics Click to edit Master title style - Introduction - Performance Analysis - Single-Cycle Processor - Multicycle Processor - Pipelined Processor - Exceptions - Advanced Microarchitecture 7-<2>
 Review: Processor Performance Click to edit Master title style Program Execution Time = (# instructions)(cycles/instruction)(seconds/cycle) = # instructions x CPI x T C 7-<3>
 Single-Cycle Performance Click to edit Master title style - T is limited by the critical path (lw) C MemtoReg Control MemWrite Unit Branch 00 PCSrc ALUControl 2:031:26 Op ALUSrc 5:0 Funct RegDst RegWrite CLK CLK CLK 101 WE3 SrcA Zero WE 0 PC' PC Instr 25:21 A1 RD10 A RD U ALUResult ReadData 1 L A RD 1 Instruction 20:16 A2 RD20 SrcB A Data Memory A31 Memory Register WriteData WD3 WD File 20:16015:111 WriteReg 4:0 PCPlus4 + SignImm <<215:0 Sign Extend PCBranch + Result 7-<4>
 Multicycle MIPS Processor Click to edit Master title style - Single-cycle microarchitecture:
+ simple - cycle time limited by longest instruction (lw) - two adders/ALUs and two memories - Multicycle microarchitecture:
+ higher clock speed + simpler instructions run faster + reuse expensive hardware on multiple cycles - sequencing overhead paid many times - Same design steps: datapath & control 7-<5>
 Multicycle State Elements Click to edit Master title style - Replace Instruction and Data memories with a single unified memory - More realistic CLK CLK CLK WE WE3 A1 RD1 PC' PC RD A A2 RD2 EN Instr / Data Memory A3 Register WD File WD37-<6>
 Multicycle Datapath: instruction fetch Click to edit Master title style - Break an instruction into multiple shorter steps. Add non architecturual register to hold intermediate results between steps.
- First consider executing lw - STEP 1: Fetch instruction. The instruction is read and stored in Instruction Register.
IRWrite CLK CLK CLK CLK WE WE3 A1 RD1 PC' PC Instr b RD A A2 RD2 EN Instr / Data Memory A3 Register WD File WD37-<7>
 Multicycle Datapath: lw register read Click to edit Master title style The next step is to read the source register containing the base address. This register is specified in Instr 25:21.
IRWrite CLK CLK CLK CLK CLK WE WE3 A 25:21 A1 RD1 PC' PC Instr b RD A A2 RD2 EN Instr / Data Memory A3 Register WD File WD37-<8>
 Multicycle Datapath: lw immediate Click to edit Master title style The next step is to read the offset which is stored in the immediate field , Instr 15:0, and it must be sign extended.
IRWrite CLK CLK CLK CLK CLK WE WE3 A 25:21 A1 RD1 PC' PC Instr b RD A A2 RD2 EN Instr / Data Memory A3 Register WD File WD3 SignImm 15:0 Sign Extend 7-<9>
 Multicycle Datapath: lw address Click to edit Master title style The address of the load is the sum of the base address and offset. ALUResult is stored in a nonarchitectural register called ALUOut.
IRWrite ALUControl 2:0 CLK CLK CLK CLK CLK WE WE3 A SrcA CLK PC' PC Instr 25:21 A1 RD1 b RD U A A2 RD2 ALUResult ALUOut EN L A Instr / Data SrcB Memory A3 Register WD File WD3 SignImm 15:0 Sign Extend 7-<10>
 Multicycle Datapath: lw memory read Click to edit Master title style The next step is to load the data from the calculated address in the memory. We add a multiplexer in front of the memory to choose the memory address, Adr, from either the PC or ALUOut. The mux select signal is called IorD, to indicate either an instruction or data address.
IorD IRWrite ALUControl 2:0 CLK CLK CLK CLK CLK WE WE3 A SrcA CLK PC' PC Instr 25:21 A1 RD1 b 0 Adr RD U A A2 RD2 ALUResult ALUOut EN L A Instr / Data SrcB Memory CLK A3 Register WD Data File WD3 SignImm 15:0 Sign Extend 7-<11>
 Multicycle Datapath: lw write register Click to edit Master title style Finally the data is written back to the register file, the destination register is specified by the rt field of the instruction, Instr20:16.
IorD IRWrite RegWrite ALUControl 2:0 CLK CLK CLK CLK CLK WE WE3 A SrcA CLK PC' PC Instr 25:21 A1 RD1 b 0 Adr RD U A A2 RD2 ALUResult ALUOut EN L A Instr / Data SrcB Memory CLK 20:16 A3 Register WD Data File WD3 SignImm 15:0 Sign Extend 7-<12>
 Multicycle Datapath: increment PC Click to edit Master title style The PC must increase by 4. In the single cycle processor, a separate adder was needed. In multiple cycle processor, we can use the existing ALU on one of the steps when it is not busy. To do so, we must insert source multiplexer to choose the PC and the constant 4 as ALU inputs. A two input multiplexer controlled by ALUSrcA chooses either the PC or register A as SrcA. A four input multiplexer controlled by ALUSrcB chooses either 4 or SignImm as SrcB. We use other two mux inputs for other instructions.
To update the PC, the ALU adds SrcA(PC) to SrcB(4), and the result is written into the program counter register.
PCWrite IorD IRWrite RegWrite ALUSrcA ALUSrcB ALUControl 1:02:0 CLK CLK CLK CLK CLK 0 SrcA WE WE3 A CLK PC' PC Instr 25:21 A1 RD11 b 0 Adr RD U A A2 RD200 ALUResult ALUOut EN EN L SrcB A Instr / Data 401 Memory CLK 20:16 A310 Register WD 11 Data File WD3 SignImm 15:0 Sign Extend 7-<13>
 Multicycle Datapath: sw Click to edit Master title style - The only new feature of sw is that we must read a second register rt from the register file and write it to memory PCWrite IorD MemWrite IRWrite RegWrite ALUSrcA ALUSrcB ALUControl 1:02:0 CLK CLK CLK CLK CLK 0 SrcA WE WE3 A CLK PC' PC Instr 25:21 A1 RD11 b 0 Adr RD B U A 20:16 A2 RD200 ALUResult ALUOut EN EN L A Instr / Data 401 SrcB Memory CLK 20:16 A310 Register WD 11 Data File WD3 SignImm 15:0 Sign Extend 7-<14>
 Multicycle Datapath: R-type Instructions Click to edit Master title style - Read from rs and rt - Write ALUResult to register file. Requires two new mux. The MemtoReg mux selects whether WD3 comes from ALUOut(for R-type instruction) or from Data (for lw). The RegDst instruction selects whether the destination register is specified in the rt or rd field.
- Write to rd (instead of rt) PCWrite IorD MemWrite IRWrite RegDst MemtoReg RegWrite ALUSrcA ALUSrcB ALUControl 1:02:0 CLK CLK CLK CLK CLK 0 SrcA WE WE3 A CLK PC' PC Instr 25:21 A1 RD11 b 0 Adr RD B U A 20:16 A2 RD200 ALUResult ALUOut EN EN L A Instr / Data 20:16401 SrcB Memory 15:11 A310 CLK 1 Register WD 110 File Data WD3 SignImm 15:0 Sign Extend 7-<15>
 Multicycle Datapath: beq, Fig.7.26 Click to edit Master title style - Determine whether values in rs and rt are equal - Calculate branch target address:
BTA = (sign-extended immediate << 2) + (PC+4) - In single cycle processor, two adders are used. In multicycle, ALU can be reused again. On one step, ALU computes PC+4 and write it back to the program counter, as was done for other instructions. On another step, the ALU uses this updated PC value to compute PC+SignImm x 4. The SrcB mux chooses this value and adds it to the PC. This sum represents the destination of branch and is stored in ALUOut.
- A new bracnch signal indicates that the beq instruction is being executed. The branch is taken if Zero is also asserted.
PCEn IorD MemWrite IRWrite RegDst MemtoReg RegWrite ALUSrcA ALUSrcB ALUControl BranchPCWrite PCSrc 1:02:0 CLK CLK CLK CLK CLK 0 SrcA WE WE3 A Zero CLK PC' b PC 0 Adr RD Instr 25:21 A1 RD1 B 1 U 0 A 20:16 A2 RD200 ALUResult ALUOut EN EN L 1 A Instr / Data 401 SrcB 20:160 Memory A310 CLK 15:111 Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<16>
 Complete Multicycle Processor Click to edit Master title style CLK PCWrite Branch PCEn IorD Control PCSrc MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:0 ALUSrcA 31:26 Op RegWrite 5:0 Funct R M CLK e e CLK CLK m CLK CLK g D t o 0 SrcA WE s t R e WE3 A Zero CLK PC' PC Instr 25:21 g A1 RD1100 Adr RD B U A 20:16 A2 RD200 ALUResult ALUOut EN EN L 1 A Instr / Data 401 SrcB 20:160 Memory A310 CLK 15:111 Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<17>
 Chapter 7 :: Topics Click to edit Master title style - Introduction - Performance Analysis - Single-Cycle Processor - Multicycle Processor - Pipelined Processor - Exceptions - Advanced Microarchitecture 7-<19>
 Control Unit Click to edit Master title style Control MemtoReg Unit RegDst IorD Multiplexer Selects PCSrc Main ALUSrcB 1:0 Controller Opcode ALUSrcA (FSM) 5:0 IRWrite MemWrite Register PCWrite Enables Branch RegWrite ALUOp 1:0 ALU Funct ALUControl 5:0 Decoder 2:07-<20>
 Main Controller FSM: Fetch Click to edit Master title style S0: Fetch Reset CLK PCWrite 1 Branch 0 PCEn IorD Control PCSrc MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:031:26 ALUSrcA Op RegWrite 5:0 Funct R M CLK e e m CLK CLK 0 CLK 0 CLK g D to 00 SrcA 0100 WE s t R e WE3 A Zero CLK 0 PC' PC 0 Adr RD Instr 25:21 g A1 RD1 B 101 U 0 EN A EN 20:16 A2 RD200 L ALUResult ALUOut 11 X A 1 Instr / Data 120:160401 SrcB Memory A310 CLK 15:111 X Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<21>
 Main Controller FSM: Fetch Click to edit Master title style S0: Fetch IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite CLK PCWrite 1 Branch 0 PCEn IorD Control PCSrc MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:031:26 ALUSrcA Op RegWrite 5:0 Funct R M CLK e e m CLK CLK 0 CLK 0 CLK g D to 00 SrcA 0100 WE s t R e WE3 A Zero CLK 0 PC' PC 0 Adr RD Instr 25:21 g A1 RD1 B 101 U 0 EN A EN 20:16 A2 RD200 L ALUResult ALUOut 11 X A 1 Instr / Data 120:160401 SrcB Memory A310 CLK 15:111 X Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<22>
 Main Controller FSM: Decode Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite 31:265:0 CLK CLK 0 SrcA WE3 PC' PC Instr 25:21 A1 RD1100 RD A 20:16 A2 RD2 ALUResult ALUOut 1 Instr / Data SrcB 20:160 Memory A315:111 Register File WD3 <<2 SignImm 15:0 Sign Extend 7-<23> RegDst Branch MemWrite MemtoReg CLK PCWrite 00 PCEn IorD Control PCSrc Unit ALUControl 2:0 IRWrite ALUSrcB 1:0 ALUSrcA Op RegWrite Funct CLK CLK X 0 CLK 0 XXX X WE A Zero CLK X XX Adr B U EN EN 00 L X A 40100 CLK X WD 11 Data Main Controller FSM:
Address Calculation Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite CLK PCWrite 0 Op = LW Branch 0 PCEn or IorD Control PCSrc S2: MemAdr Op = SW MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:031:26 ALUSrcA Op RegWrite 5:0 Funct R M CLK e e m CLK CLK 1 CLK 0 CLK g D to 00 SrcA 010 X WE s t R e WE3 A Zero CLK X PC' PC 0 Adr RD Instr 25:21 g A1 RD1 B 110 U 0 EN A EN 20:16 A2 RD200 L ALUResult ALUOut 11 X A 0 Instr / Data 020:160401 SrcB Memory A310 CLK 15:111 X Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<24>
 Main Controller FSM:
Address Calculation Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite CLK PCWrite 0 Op = LW Branch 0 PCEn or IorD Control PCSrc S2: MemAdr Op = SW MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:031:26 ALUSrcA Op RegWrite ALUSrcA = 15:0 Funct ALUSrcB = 10 ALUOp = 00 R M CLK e e m CLK CLK 1 CLK 0 CLK g D to 00 SrcA 010 X WE s t R e WE3 A Zero CLK X PC' PC 0 Adr RD Instr 25:21 g A1 RD1 B 110 U 0 EN A EN 20:16 A2 RD200 L ALUResult ALUOut 11 X A 0 Instr / Data 020:160401 SrcB Memory A310 CLK 15:111 X Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<25>
 Main Controller FSM: lw Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite Op = LW or S2: MemAdr Op = SW ALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 Op = LW S3: MemRead IorD = 1 S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<26>
 Main Controller FSM: sw Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite Op = LW or S2: MemAdr Op = SW ALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 Op = SW Op = LW S5: MemWrite S3: MemRead IorD = 1 IorD = 1 MemWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<27>
 Main Controller FSM: R-Type Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWrite Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 00 ALUOp = 10 Op = SW Op = LW S7: ALU S5: MemWrite Writeback S3: MemRead RegDst = 1 IorD = 1 IorD = 1 MemtoReg = 0 MemWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<28>
 Main Controller FSM: beq Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUSrcA = 0 ALUOp = 00 ALUSrcB = 11 PCSrc = 0 ALUOp = 00 IRWrite PCWrite Op = BEQ Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute S8: Branch ALUSrcA = 1 ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 00 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 01 ALUOp = 00 ALUOp = 10 PCSrc = 1 Branch Op = SW Op = LW S7: ALU S5: MemWrite Writeback S3: MemRead RegDst = 1 IorD = 1 IorD = 1 MemtoReg = 0 MemWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<29>
 Complete Multicycle Controller FSM Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUSrcA = 0 ALUOp = 00 ALUSrcB = 11 PCSrc = 0 ALUOp = 00 IRWrite PCWrite Op = BEQ Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute S8: Branch ALUSrcA = 1 ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 00 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 01 ALUOp = 00 ALUOp = 10 PCSrc = 1 Branch Op = SW Op = LW S7: ALU S5: MemWrite Writeback S3: MemRead RegDst = 1 IorD = 1 IorD = 1 MemtoReg = 0 MemWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<30>
 Main Controller FSM: addi Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUSrcA = 0 ALUOp = 00 ALUSrcB = 11 PCSrc = 0 ALUOp = 00 IRWrite PCWrite Op = ADDI Op = BEQ Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute S9: ADDI S8: Branch Execute ALUSrcA = 1 ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 00 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 01 ALUOp = 00 ALUOp = 10 PCSrc = 1 Branch Op = SW Op = LW S7: ALU S5: MemWrite S10: ADDI Writeback S3: MemRead Writeback RegDst = 1 IorD = 1 IorD = 1 MemtoReg = 0 MemWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<31>
 Main Controller FSM: addi Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 ALUSrcB = 01 ALUSrcA = 0 ALUOp = 00 ALUSrcB = 11 PCSrc = 0 ALUOp = 00 IRWrite PCWrite Op = ADDI Op = BEQ Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute S9: ADDI S8: Branch Execute ALUSrcA = 1 ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 00 ALUSrcA = 1 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 01 ALUSrcB = 10 ALUOp = 00 ALUOp = 10 PCSrc = 1 ALUOp = 00 Branch Op = SW Op = LW S7: ALU S5: MemWrite S10: ADDI Writeback S3: MemRead Writeback RegDst = 1 RegDst = 0 IorD = 1 IorD = 1 MemtoReg = 0 MemtoReg = 0 MemWrite RegWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<32>
 Extended Functionality: j Click to edit Master title style PCEn IorD MemWrite IRWrite RegDst MemtoReg RegWrite ALUSrcA ALUSrcB ALUControl BranchPCWrite PCSrc 1:02:01:0 CLK CLK CLK CLK CLK 0 SrcA WE WE3 A 31:28 Zero CLK PC' PC Instr 25:21 A1 RD11000 Adr RD B U A 20:16 A2 RD200 ALUResult ALUOut EN EN L 01 A Instr / Data 20:160401 SrcB 10 Memory A310 CLK 15:111 Register PCJump WD 110 File Data WD3 <<227:0 <<2 SignImm 15:0 Sign Extend 25:0 (jump) 7-<33>
 Control FSM: j Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 S11: Jump ALUSrcB = 01 ALUSrcA = 0 Op = J ALUOp = 00 ALUSrcB = 11 PCSrc = 00 ALUOp = 00 IRWrite PCWrite Op = ADDI Op = BEQ Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute S9: ADDI S8: Branch Execute ALUSrcA = 1 ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 00 ALUSrcA = 1 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 01 ALUSrcB = 10 ALUOp = 00 ALUOp = 10 PCSrc = 01 ALUOp = 00 Branch Op = SW Op = LW S7: ALU S5: MemWrite S10: ADDI Writeback S3: MemRead Writeback RegDst = 1 RegDst = 0 IorD = 1 IorD = 1 MemtoReg = 0 MemtoReg = 0 MemWrite RegWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<34>
 Control FSM: j Click to edit Master title style S0: Fetch S1: Decode IorD = 0 Reset AluSrcA = 0 S11: Jump ALUSrcB = 01 ALUSrcA = 0 Op = J ALUOp = 00 ALUSrcB = 11 PCSrc = 10 PCSrc = 00 ALUOp = 00 PCWrite IRWrite PCWrite Op = ADDI Op = BEQ Op = LW Op = R-type or S2: MemAdr Op = SW S6: Execute S9: ADDI S8: Branch Execute ALUSrcA = 1 ALUSrcA = 1 ALUSrcA = 1 ALUSrcB = 00 ALUSrcA = 1 ALUSrcB = 10 ALUSrcB = 00 ALUOp = 01 ALUSrcB = 10 ALUOp = 00 ALUOp = 10 PCSrc = 01 ALUOp = 00 Branch Op = SW Op = LW S7: ALU S5: MemWrite S10: ADDI Writeback S3: MemRead Writeback RegDst = 1 RegDst = 0 IorD = 1 IorD = 1 MemtoReg = 0 MemtoReg = 0 MemWrite RegWrite RegWrite S4: Mem Writeback RegDst = 0 MemtoReg = 1 RegWrite 7-<35>
 Multicycle Performance Click to edit Master title style - Instructions take different number of cycles:
- 3 cycles: beq, j - 4 cycles: R-Type, sw, addi - 5 cycles: lw - CPI is weighted average - SPECINT2000 benchmark:
- 25% loads - 10% stores - 11% branches - 2% jumps - 52% R-type Average CPI = (0.11 + 0.02)(3) + (0.52 + 0.10)(4) + (0.25)(5) = 4.127-<36>
 Multicycle Performance Click to edit Master title style - Multicycle critical path:
T = c CLK PCWrite Branch PCEn IorD Control PCSrc MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:031:26 ALUSrcA Op RegWrite 5:0 Funct R M CLK e e m CLK CLK CLK CLK g D to 0 SrcA WE s t R e WE3 A Zero CLK PC' PC Instr 25:21 g A1 RD1100 Adr RD B U A 20:16 A2 RD200 ALUResult ALUOut EN EN L 1 A Instr / Data 401 SrcB 20:160 Memory A310 CLK 15:111 Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<37>
 Multicycle Performance Click to edit Master title style - Multicycle critical path:
T = t + t + max(t + t , t ) + t c pcq mux ALU mux mem setup CLK PCWrite Branch PCEn IorD Control PCSrc MemWrite Unit ALUControl 2:0 IRWrite ALUSrcB 1:031:26 ALUSrcA Op RegWrite 5:0 Funct R M CLK e e m CLK CLK CLK CLK g D to 0 SrcA WE s t R e WE3 A Zero CLK PC' PC Instr 25:21 g A1 RD1100 Adr RD B U A 20:16 A2 RD200 ALUResult ALUOut EN EN L 1 A Instr / Data 401 SrcB 20:160 Memory A310 CLK 15:111 Register WD 110 File Data WD3 <<2 SignImm 15:0 Sign Extend 7-<38>
 Multicycle Performance Example Click to edit Master title style Element Parameter Delay (ps) Register clock-to-Q t 30 pcq Register setup t 20 setup Multiplexer t 25 mux ALU t 200 ALU Memory read t 250 mem Register file read t 150 RFread Register file setup t 20 RFsetup T = c 7-<39>
 Multicycle Performance Example Click to edit Master title style Element Parameter Delay (ps) Register clock-to-Q t 30 pcq_PC Register setup t 20 setup Multiplexer t 25 mux ALU t 200 ALU Memory read t 250 mem Register file read t 150 RFread Register file setup t 20 RFsetup There are two possible critical path that would limit the cycle time T = t + t + max(t + t , t ) + t c pcq_PC mux ALU mux mem setup = t + t + t + t pcq_PC mux mem setup = [30 + 25 + 250 + 20] ps = 325 ps 7-<40>
 Multicycle Performance Example Click to edit Master title style - For a program with 100 billion instructions executing on a multicycle MIPS processor - CPI = 4.12 - T = 325 ps c Execution Time = 7-<41>
 Multicycle Performance Example Click to edit Master title style - For a program with 100 billion instructions executing on a multicycle MIPS processor - CPI = 4.12 - T = 325 ps c Execution Time = (# instructions) × CPI × T c = (100 × 109)(4.12)(325 × 10-12) = 133.9 seconds - This is slower than the single-cycle processor (92.5 seconds). Why?
7-<42>
 Multicycle Performance Example Click to edit Master title style - For a program with 100 billion instructions executing on a multicycle MIPS processor - CPI = 4.12 - T = 325 ps c Execution Time = (# instructions) × CPI × T c = (100 × 109)(4.12)(325 × 10-12) = 133.9 seconds - This is slower than the single-cycle processor (92.5 seconds). Why?
- Not all steps the same length - Sequencing overhead for each step (t + t = 50 ps) pcq setup 7-<43>