Chapter 7 :: Microarchitecture Digital Design and Computer Architecture Adapted from David Money Harris and Sarah L. Harris' book 7-<1>
 Introduction - Microarchitecture: how to Application programs Software implement an architecture in Operating hardware device drivers Systems - Processor:
instructions Architecture registers - Datapath: functional blocks Micro- datapaths - Control: control signals architecture controllers adders Logic memories Digital AND gates Circuits NOT gates Analog amplifiers Circuits filters transistors Devices diodes Physics electrons 7-<2>
 Microarchitecture - Multiple implementations for a single architecture:
- Single-cycle - Each instruction executes in a single cycle - Multicycle - Each instruction is broken up into a series of shorter steps - Pipelined - Each instruction is broken up into a series of steps - Multiple instructions execute at once.
7-<3>
 7.2 Processor Performance - Program execution time Execution Time = (# instructions)(cycles/instruction)(seconds/cycle) - Definitions:
- Cycles/instruction = CPI - Seconds/cycle = clock period - 1/CPI = Instructions/cycle = IPC - Challenge is to satisfy constraints of:
- Cost - Power - Performance 7-<4>
 7.3 Single Cycle Processor:
- We consider a subset of MIPS instructions:
- R-type instructions: , , , , and or add sub slt - Memory instructions: , lw sw - Branch instructions:
beq - Later consider adding and addi j 7-<5>
 Architectural State - Determines everything about a processor:
- PC - 32 registers - Memory 7-<6>
 MIPS State Elements CLK CLK CLK PC' PC WE3 WE A1 RD13232 A RD 5323232 A2 RD2 A RD 532 Instruction 3232 Data Memory A3 Memory Register WD3 WD 32 File 327-<7>
 7.3.1 Single-Cycle MIPS Processor - Datapath - Control 7-<8>
 Single-Cycle Datapath: lw fetch - First consider executing lw - STEP 1: Fetch instruction CLK CLK CLK WE3 WE PC Instr A1 RD1 PC' A RD A RD Instruction A2 RD2 Data Memory A3 Memory Register WD3 WD File 7-<9>
 Single-Cycle Datapath: lw register read - STEP 2: Read source operands from register file CLK CLK CLK 25:21 WE3 WE A1 RD1 PC' PC Instr A RD A RD Instruction A2 RD2 Data Memory A3 Memory Register WD3 WD File 7-<10>
 Single-Cycle Datapath: lw immediate - STEP 3: Sign-extend the immediate CLK CLK CLK WE3 WE PC' PC Instr 25:21 A1 RD1 A RD A RD Instruction A2 RD2 Data Memory A3 Memory Register WD3 WD File SignImm 15:0 Sign Extend 7-<11>
 Single-Cycle Datapath: lw address - STEP 4: Compute the memory address ALUControl 2:0 CLK CLK CLK WE3 Zero WE SrcA 25:21 A1 RD1 PC' PC Instr A RD U ALUResult L A RD Instruction A A2 RD2 SrcB Data Memory A3 Memory Register WD3 WD File SignImm 15:0 Sign Extend 7-<12>
 Single-Cycle Datapath: lw memory read - STEP 5: Read data from memory and write it back to register file RegWrite ALUControl 2:01010 CLK CLK CLK WE3 SrcA Zero WE PC' PC Instr 25:21 A1 RD1 A RD U ALUResult ReadData L A RD Instruction A A2 RD2 SrcB Data Memory 20:16 A3 Memory Register WD3 WD File SignImm 15:0 Sign Extend 7-<13>
 Single-Cycle Datapath: lw PC increment - STEP 6: Determine the address of the next instruction RegWrite ALUControl 2:01010 CLK CLK CLK WE3 SrcA Zero WE PC' PC Instr 25:21 A1 RD1 A RD U ALUResult ReadData L A RD Instruction A A2 RD2 SrcB Data Memory 20:16 A3 Memory Register WD3 WD File PCPlus4 + SignImm 415:0 Sign Extend Result 7-<14>
 Single-Cycle Datapath: LW $t1, 32($t2) :
load data in Data Memory address ($t2+32) to reg $t1 in Register File CLK A RD Instruction Memory SignImm 7-<15> + RegWrite ALUControl 2:0 CLK CLK WE3 SrcA Zero WE PC' PC Instr 25:21 A1 RD1 ALUResult ReadData A RD A2 RD2 SrcB Data 20:16 A3 Memory Register WD3 WD File PCPlus4415:0 Sign Extend Result ULA $t2 $t1321010 Syntax: LW $t1, 32($t2) Action: $t1 = Mem[$t2 + 32] .Fetch from memory address[$t2+32]. And load to register $t1 in register file Syntax: SW $3, 12($4)
 Single-Cycle Datapath: sw $s0, 0($t0) - Write data in to memory rt 3130292827262524232221201918171615141312111009080706050403020100 OP RS RT 16 bit Address/Immediate RegWrite ALUControl MemWrite 2:000101 CLK CLK CLK WE3 SrcA Zero WE PC' PC Instr 25:21 A1 RD1 A RD U ALUResult ReadData L A RD Instruction 20:16 A A2 RD2 SrcB Data Memory 20:16 A3 Memory Register WriteData WD3 WD File PCPlus4 + SignImm 415:0 Sign Extend Result 7-<16>
 Chapter 7 :: Microarchitecture Digital Design and Computer Architecture Adapted from David Money Harris and Sarah L. Harris' book 7-<17>
 Single-Cycle Datapath: R-type : ADD $t0 $t1 $t2 - Read from rs and rt - Write ALUResult to register file - Write to rd (instead of rt) - Important: Add multiplexers(lw and R type use same A3: destination reg, but from different source;Use same srcB, but from different source, LW from imm field;use same WD3, but from different source) $t1 $t2 $t0 CLK A RD Instruction Memory SignImm 7-<18> + RegWrite RegDst ALUSrc ALUControl MemWrite MemtoReg 2:0 CLK CLK 25:21 WE3 Zero WE SrcA PC' PC Instr A1 RD10 ALUResult ReadData A RD 120:16 A2 RD20 SrcB Data A31 Memory Register WriteData WD3 WD File 20:1615:111 WriteReg 4:0 PCPlus4415:0 Sign Extend Result ULA 3130292827262524232221201615111009080706050403020100 OP RS RT RD SHAMT FUNCT 110 varies 0 Single-Cycle Datapath: beq - Determine whether values in rs and rt are equal - Calculate branch target address:
BTA = (sign-extended immediate << 2) + (PC+4) ) - The immediate must be sign-extended and multiplier by 4 (left shift by 2, since address are multiple of 4) - PCBranch is selected if the instruction is a branch and the ZERO flag is asserted(when SrcA=SrcB).
CLK A RD Instruction Memory SignImm 7-<19> + CLK WE3 WE 0 PC' PC Instr 25:21 A1 RD10 A RD 120:16 A2 RD20 SrcB Data A31 Memory Register WD3 WD File 20:16015:111 <<2415:0 Sign Extend + PCSrc RegWrite RegDst ALUSrc ALUControl Branch MemWrite MemtoReg 2:0 CLK SrcA Zero ALUResult ReadData WriteData WriteReg 4:0 PCPlus4 PCBranch Result ULA 0 x 01101 x Addressing Modes PC-Relative Addressing 0x10 beq $t0, $0, else #else=3: (0x20-0x14)/40x14 addi $v0, $0, 10x18 addi $sp, $sp, i 0x1C jr $ra 0x20 else: addi $a0, $a0, -10x24 jal factorial Assembly Code Field Values op rs rt imm 4803 beq $t0, $0, else (beq $t0, $0, 3) 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 6-<20>
 Single-Cycle Datapath: beq $s1, $s2, 12 - Determine whether values in rs and rt are equal - Calculate branch target address:
BTA = (sign-extended immediate << 2) + (PC+4) CLK A RD Instruction Memory SignImm Syntax: BEQ $1, $2, 12 Action: If ($1 != $2), PC = PC + 4 Action: If ($1 == $2), PC = PC + 4 + 12x47-<21> + CLK WE3 WE 0 PC' PC Instr 25:21 A1 RD10 A RD 1 SrcB 20:16 A2 RD20 Data A31 Memory Register WD3 WD File 20:16015:111 <<2415:0 Sign Extend + PCSrc RegWrite RegDst ALUSrc ALUControl Branch MemWrite MemtoReg 2:0 CLK Zero SrcA ReadData ALUResult WriteData WriteReg 4:0 PCPlus4 PCBranch Result ULA 0 x 01101 x 3130292827262524232221201918171615141312111009080706050403020100 OP RS RT 16 bit Address/Immediate
 Control Unit: Load Word 3130292827262524232221201918171615141312111009080706050403020100 OP RS RT 16 bit Address/Immediate MemtoReg Control MemWrite Unit Branch PCSrc ALUControl 2:031:26 Op ALUSrc 5:0 Funct RegDst RegWrite CLK CLK CLK WE3 SrcA Zero WE 0 PC' PC Instr 25:21 A1 RD10 A RD U ALUResult ReadData L A RD 1 In M st e r m uc o t r io y n 20:16 A2 RD20 SrcB A Data A31 Memory Register WriteData WD3 WD File 20:16015:111 WriteReg 4:0 PCPlus4 + SignImm <<2415:0 Sign Extend PCBranch + Result 1.The instruction is fetched, and the PC is incremented 2. A register value is read from the register file 3.The ALU computes the sum of the value read from the read from the register file and the sign-extended, lower 16 bits of the instruction(offset) 4. The sum from the ALU is used as the address of the data memory file 5. The data from the memory unit is written into the register file; the register destination is given by bits 20:16 of the instruction.
Instruction Op RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp 5:01:0 lw 100011101001007-<22>
 Control Unit:R-type 3130292827262524232221201918171615141312111009080706050403020100 OP RS RT RD SHAMT FUNCT MemtoReg Control MemWrite Unit Branch PCSrc ALUControl 2:031:26 Op ALUSrc 5:0 Funct RegDst RegWrite CLK CLK CLK WE3 SrcA Zero WE 0 PC' PC Instr 25:21 A1 RD10 A RD U ALUResult ReadData L A RD 1 Instruction 20:16 A2 RD20 SrcB A Data Memory A31 Memory Register WriteData WD3 WD File 20:16015:111 WriteReg 4:0 PCPlus4 + SignImm <<2415:0 Sign Extend PCBranch + Result Instruction Op RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp 5:01:0 R-type 000000110000107-<23> lw 10001110100100
 Control Unit: branch OP RS RT 16 bit Address/Immediate MemtoReg Control MemWrite Unit Branch PCSrc ALUControl 2:031:26 Op ALUSrc 5:0 Funct RegDst RegWrite CLK CLK CLK WE3 SrcA Zero WE 0 PC' PC Instr 25:21 A1 RD10 A RD U ALUResult ReadData L A RD 1 In M st e r m uc o t r io y n 20:16 A2 RD20 SrcB A Data A31 Memory Register WriteData WD3 WD File 20:16015:111 WriteReg 4:0 PCPlus4 + SignImm <<2415:0 Sign Extend PCBranch + Fig.5.21 Result 1.The instruction is fetched, and the PC is incremented 2. Two registers are read from the register file 3.The ALU performs a subtract on the data values read from the register file. The value of PC +4 is added to the sign-extended, lower 16 bits of the instruction (offset) shifted left by two; the result is the branch target address 4. The zero result from the ALU is used to decide which adder result to store into the PC Instruction Op RegWrite RegDst AluSrc Branch MemWrite MemtoReg ALUOp 5:01:0 beq 0001000 X 010 X 017-<24>
 Complete Single-Cycle Processor MemtoReg Control MemWrite Unit Branch PCSrc ALUControl 2:031:26 Op ALUSrc 5:0 Funct RegDst RegWrite CLK CLK CLK WE3 SrcA Zero WE 0 PC' PC Instr 25:21 A1 RD10 A RD U ALUResult ReadData L A RD 1 Instruction 20:16 A2 RD20 SrcB A Data Memory A31 Memory Register WriteData WD3 WD File 20:16015:111 WriteReg 4:0 PCPlus4 + SignImm <<215:0 Sign Extend PCBranch + Result 7-<25>
 Single-Cycle Datapath Example: or MemtoReg Control MemWrite Unit Branch 0 PCSrc ALUControl 2:031:26 Op ALUSrc 5:0 Funct RegDst RegWrite CLK CLK CLK 100001 WE3 SrcA Zero WE 0 PC' PC Instr 25:21 A1 RD10 A RD U ALUResult ReadData 0 L A RD 1 Instruction 20:16 A2 RD20 SrcB A Data Memory A31 Memory Register WriteData WD3 WD File 20:16015:111 WriteReg 4:0 PCPlus4 + SignImm <<215:0 Sign Extend PCBranch + Result 7-<26>
 Multicycle MIPS Processor - Single-cycle microarchitecture:
+ simple - cycle time limited by longest instruction ( ) lw - two adders/ALUs and two memories - Multicycle microarchitecture:
+ higher clock speed + simpler instructions run faster + reuse expensive hardware on multiple cycles - sequencing overhead paid many times - Same design steps: datapath & control 7-<27>